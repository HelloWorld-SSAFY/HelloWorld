pipeline {
  // 빌드 때마다 쿠버네티스에 임시 Pod 에이전트를 띄움
  agent {
    kubernetes {
      label 'k8s-ephemeral'
      defaultContainer 'jnlp'
      yaml ```
apiVersion: v1
kind: Pod
metadata:
  labels:
    ci: jenkins
spec:
  # apps 네임스페이스에 있는 ServiceAccount (RBAC 미리 생성 필요)
  serviceAccountName: jenkins
  restartPolicy: Never

  securityContext:
    fsGroup: 1000


  containers:
    - name: jnlp
      image: jenkins/inbound-agent:latest
      tty: true
      securityContext:
        runAsUser: 1000
        runAsGroup: 1000

    - name: kaniko
      image: gcr.io/kaniko-project/executor:debug
      command: ["sh","-c","trap : TERM INT; sleep infinity & wait"]
      volumeMounts:
        - name: docker-config
          mountPath: /kaniko/.docker
      securityContext:
        runAsUser: 0

    - name: kubectl
      image: alpine:3.20
      imagePullPolicy: IfNotPresent
      securityContext: { runAsUser: 0 }   # apk 설치용 루트
      command: ["sh","-lc","set -eux; \
        apk add --no-cache curl ca-certificates; \
        arch=$(uname -m); case $arch in x86_64) arch=amd64 ;; aarch64) arch=arm64 ;; *) echo unsupported: $arch; exit 1 ;; esac; \
        curl -fsSL -o /usr/local/bin/kubectl https://dl.k8s.io/release/v1.33.4/bin/linux/${arch}/kubectl; \
        chmod +x /usr/local/bin/kubectl; \
        kubectl version --client=true; \
        trap : TERM INT; sleep infinity & wait"]
      tty: true
      workingDir: /home/jenkins/agent


  volumes:
    - name: docker-config
      emptyDir: {}
```
    }
  }

  options { timestamps(); ansiColor('xterm') }

  environment {
    // Docker Registry
    REGISTRY   = "docker.io"
    IMAGE_REPO = "opensongce/msa"

    // Kubernetes
    // KUBECONFIG는 사용 안 함(에이전트 Pod 내 in-cluster SA 사용)
    K8S_NS     = "apps"

    // Jenkins Credentials ID for DockerHub (username/password)
    DH_CREDS   = "dockerhub-ci"
  }

  stages {
    stage('Checkout') {
      steps {
        checkout scm
        sh 'git --version; git rev-parse --short HEAD'
      }
    }

    stage('Kube debug') {
      steps {
        container('kubectl') {
          sh '''
            which sh || true
            ls -ld /home/jenkins/agent || true
            kubectl version --client --short || true
            kubectl auth can-i get ns || true
          '''
        }
      }
    }


    stage('Detect changed (code/k8s/ingress)') {
      steps {
        script {
          sh '''
            set -e
            # 기준: 최근 성공 커밋(없으면 최초 커밋)
            base=${GIT_PREVIOUS_SUCCESSFUL_COMMIT:-$(git rev-list --max-parents=0 HEAD)}
            changed_files=$(git diff --name-only "$base"...HEAD || true)

            # 1) 서비스 코드 변경: helloworld-server/<svc>/...
            svc_from_code=$(printf "%s\n" "$changed_files" \
              | grep -E '^helloworld-server/[^/]+/' \
              | awk -F/ '{print $2}' \
              | grep -vE '^(k8s)$' \
              | sort -u || true)

            # 2) k8s 매니페스트 변경: helloworld-server/k8s/apps/<svc>/**.yaml
            svc_from_k8s=$(printf "%s\n" "$changed_files" \
              | grep -E '^helloworld-server/k8s/apps/[^/]+/.*\\.ya?ml$' \
              | awk -F/ '{print $4}' \
              | sort -u || true)

            # 3) ingress 변경 감지
            ingress_changed=$(printf "%s\n" "$changed_files" \
              | grep -E '^helloworld-server/k8s/ingress/.*\\.ya?ml$' || true)

            mkdir -p helloworld-server
            echo "$svc_from_code" | tr '\\n' ' ' > helloworld-server/changed_code.txt
            echo "$svc_from_k8s"  | tr '\\n' ' ' > helloworld-server/changed_k8s.txt
            if [ -n "$ingress_changed" ]; then echo "true" > helloworld-server/ingress_changed; else : > helloworld-server/ingress_changed; fi

            echo "Code-changed services: $(cat helloworld-server/changed_code.txt)"
            echo "K8s-changed services : $(cat helloworld-server/changed_k8s.txt)"
            echo "Ingress changed      : $(cat helloworld-server/ingress_changed | tr -d '\\n' | sed -e 's/^$/false/')"
          '''
          env.CHANGED_CODE    = sh(script: "cat helloworld-server/changed_code.txt 2>/dev/null", returnStdout: true).trim()
          env.CHANGED_K8S     = sh(script: "cat helloworld-server/changed_k8s.txt  2>/dev/null", returnStdout: true).trim()
          env.INGRESS_CHANGED = sh(script: "cat helloworld-server/ingress_changed 2>/dev/null", returnStdout: true).trim()

          // 빌드는 "코드 변경"만, 배포는 "코드 ∪ k8s"
          def buildSet = (env.CHANGED_CODE ?: "").trim()
          def merged   = (env.CHANGED_CODE + " " + env.CHANGED_K8S).trim()
          def deploySet = merged ? merged.tokenize().unique().join(' ') : ''

          env.BUILD_SERVICES  = buildSet
          env.DEPLOY_SERVICES = deploySet

          echo "BUILD_SERVICES : ${env.BUILD_SERVICES ?: '<none>'}"
          echo "DEPLOY_SERVICES: ${env.DEPLOY_SERVICES ?: '<none>'}"
        }
      }
    }

    // 도커 데몬/소켓 없이 Kaniko로 이미지 빌드+푸시
    stage('Docker build & push (Kaniko)') {
      when { expression { return (env.BUILD_SERVICES ?: "").trim() } }
      steps {
        container('kaniko') {
          withCredentials([usernamePassword(credentialsId: env.DH_CREDS, usernameVariable: 'DH_USER', passwordVariable: 'DH_TOKEN')]) {
            sh '''
set -eux

# 1) Docker auth JSON (정확한 따옴표/형식)
rm -f /kaniko/.docker/config.json
mkdir -p /kaniko/.docker
auth="$(printf "%s:%s" "$DH_USER" "$DH_TOKEN" | base64 | tr -d '\n')"

cat >/kaniko/.docker/config.json <<EOF
{"auths":{"https://index.docker.io/v1/":{"auth":"$auth"}}}
EOF

# 확인
cat /kaniko/.docker/config.json

# 2) 빌드/푸시
SHA="${GIT_COMMIT:0:7}"
echo "[kaniko] BUILD_SERVICES=${BUILD_SERVICES}  SHA=${SHA}"

for svc in ${BUILD_SERVICES}; do
  ctx="helloworld-server/${svc}"
  df="${ctx}/Dockerfile"
  [ -f "${df}" ] || { echo "[kaniko] skip: ${df} not found (svc=${svc})"; continue; }

  img="${REGISTRY}/${IMAGE_REPO}:${svc}-${SHA}"
  latest="${REGISTRY}/${IMAGE_REPO}:${svc}-latest"

  echo "[kaniko] ==> Build/Push ${img}"
  /kaniko/executor \
    --context="${ctx}" \
    --dockerfile="${df}" \
    --destination="${img}" \
    --destination="${latest}" \
    --single-snapshot \
    --verbosity=info
done
'''
          }
        }
      }
    }




    // 임시 에이전트 SA는 네임스페이스 생성 권한이 없을 수 있어요.
    //    ns.yaml 적용이 꼭 필요하면 ClusterRole이 필요합니다. 기본은 스킵/존재 확인만 권장.
    stage('Ensure namespace (optional)') {
      steps {
        container('kubectl') {
          sh '''
            set -e
            kubectl get ns ${K8S_NS} >/dev/null 2>&1 || echo "NOTE: namespace ${K8S_NS} not found (skip creating in this pipeline)"
          '''
        }
      }
    }

    stage('Deploy to k3s (services)') {
        when { expression { return (env.DEPLOY_SERVICES ?: "").trim() } }
        steps {
            container('kubectl') {
                sh '''
bash -euo pipefail -c '
SHA=$(git -C helloworld-server rev-parse --short HEAD)
ns="${K8S_NS}"

for svc in ${DEPLOY_SERVICES}; do
  man_dir="helloworld-server/k8s/apps/${svc}"
  img="${REGISTRY}/${IMAGE_REPO}:${svc}-${SHA}"

  # 1) 매니페스트 적용(디렉터리면 -f로 한번에)
  if [ -d "$man_dir" ]; then
    echo "==> apply ${man_dir}"
    kubectl -n "${ns}" apply -f "${man_dir}"
  else
    echo "warn: manifest dir not found: ${man_dir}"
    continue
  fi

  # 2) 워크로드 타입 판별 (StatefulSet 우선, 없으면 Deployment)
  if kubectl -n "${ns}" get statefulset "${svc}" >/dev/null 2>&1; then
    kind="statefulset"
  elif kubectl -n "${ns}" get deploy "${svc}" >/dev/null 2>&1; then
    kind="deploy"
  else
    echo "warn: no Deployment/StatefulSet named ${svc} (skip rolling)"
    continue
  fi

  # 3) 코드 변경된 서비스만 이미지 롤링
  if echo " ${CHANGED_CODE} " | grep -q " ${svc} "; then
    echo "==> Rolling (code-changed) ${svc} -> ${img}"
    if [ "${kind}" = "statefulset" ]; then
      kubectl -n "${ns}" set image statefulset/${svc} ${svc}="${img}"
      kubectl -n "${ns}" rollout status statefulset/${svc} --timeout=300s
    else
      kubectl -n "${ns}" set image deploy/${svc} ${svc}="${img}"
      kubectl -n "${ns}" rollout status deploy/${svc} --timeout=300s
    fi
  else
    echo "==> K8s-only change for ${svc}: skip image update"
  fi
done
'
'''
            }
        }
    }





    stage('Deploy to k3s (ingress)') {
      when { expression { return (env.INGRESS_CHANGED ?: "").trim() } }
      steps {
        container('kubectl') {
          sh '''
            set -e
            if [ -d "helloworld-server/k8s/ingress" ]; then
              echo "==> Ingress changed: applying helloworld-server/k8s/ingress"
              kubectl -n ${K8S_NS} apply -f helloworld-server/k8s/ingress
            else
              echo "skip: ingress dir not found"
            fi
          '''
        }
      }
    }
  }

  post {
    failure { script { currentBuild.description = "Failed" } }
    success { script { currentBuild.description = "OK" } }
  }
}
