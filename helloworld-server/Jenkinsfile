properties([gitLabConnection('jenkins-gitlab-api')])

pipeline {
  // 빌드 때마다 쿠버네티스에 임시 Pod 에이전트를 띄움
  agent {
    kubernetes {
      label 'k8s-ephemeral'
      defaultContainer 'jnlp'
      yaml '''
apiVersion: v1
kind: Pod
metadata:
  labels:
    ci: jenkins
spec:
  serviceAccountName: jenkins
  restartPolicy: Never
  securityContext:
    fsGroup: 1000

  containers:
    - name: jnlp
      image: jenkins/inbound-agent:latest
      tty: true
      securityContext:
        runAsUser: 1000
        runAsGroup: 1000

    - name: kaniko
      image: gcr.io/kaniko-project/executor:debug
      command: ["sh","-c","trap : TERM INT; sleep infinity & wait"]
      volumeMounts:
        - name: docker-config
          mountPath: /kaniko/.docker
      securityContext:
        runAsUser: 0

    - name: kubectl
      image: alpine:3.20
      imagePullPolicy: IfNotPresent
      securityContext: { runAsUser: 0 }
      command: ["sh","-lc","set -eux; \
        apk add --no-cache curl ca-certificates bash git; \
        arch=$(uname -m); case $arch in x86_64) arch=amd64 ;; aarch64) arch=arm64 ;; *) echo unsupported: $arch; exit 1 ;; esac; \
        curl -fsSL -o /usr/local/bin/kubectl https://dl.k8s.io/release/v1.33.4/bin/linux/${arch}/kubectl; \
        chmod +x /usr/local/bin/kubectl; \
        kubectl version --client=true; \
        trap : TERM INT; sleep infinity & wait"]
      tty: true
      workingDir: /home/jenkins/agent

  volumes:
    - name: docker-config
      emptyDir: {}
'''
    }
  }

  options { timestamps(); ansiColor('xterm') }

  environment {
    // Docker Registry
    REGISTRY   = "docker.io"
    IMAGE_REPO = "opensongce/msa"

    // Kubernetes
    // KUBECONFIG는 사용 안 함(에이전트 Pod 내 in-cluster SA 사용)
    K8S_NS     = "apps"

    // Jenkins Credentials ID for DockerHub (username/password)
    DH_CREDS   = "dockerhub-ci"
  }

  stages {
    stage('Register checks') {
      steps {
        script {
          gitlabBuilds(builds: [
            '1) checkout',
            '2) kube-debug',
            '3) detect-changed',
            '4) build&push',
            '5) ensure-ns',
            '6) deploy-services',
            '7) deploy-ingress',
            '8) overall'
          ]){
            echo 'registered pending checks'
          }
        }
      }
    }

    stage('Checkout') {
      steps {
        gitlabCommitStatus(name: '1) checkout') {
          checkout scm
          container('kubectl') {
            sh '''
              set -e
              git --version
              git config --global --add safe.directory "$WORKSPACE" || true
              git rev-parse --short HEAD
            '''
          }
        }
      }
    }

    stage('Kube debug') {
      steps {
        gitlabCommitStatus(name: '2) kube-debug') {
          container('kubectl') {
            sh '''
              which sh || true
              ls -ld /home/jenkins/agent || true
              kubectl version --client --short || true
              kubectl auth can-i get ns || true
            '''
          }
        }
      }
    }

    stage('Detect changed (code/k8s/ingress)') {
      steps {
        gitlabCommitStatus(name: '3) detect-changed') {
          script {
            container('kubectl') {
              sh '''
                set -e
                G='git -c safe.directory="$WORKSPACE"'
                base=${GIT_PREVIOUS_SUCCESSFUL_COMMIT:-$($G rev-list --max-parents=0 HEAD)}
                changed_files=$($G diff --name-only "$base"...HEAD || true)

                svc_from_code=$(printf "%s\n" "$changed_files" \
                  | grep -E '^helloworld-server/[^/]+/' \
                  | awk -F/ '{print $2}' \
                  | grep -vE '^(k8s)$' \
                  | sort -u || true)

                svc_from_k8s=$(printf "%s\n" "$changed_files" \
                  | grep -E '^helloworld-server/k8s/apps/[^/]+/.*\\.ya?ml$' \
                  | awk -F/ '{print $4}' \
                  | sort -u || true)

                ingress_changed=$(printf "%s\n" "$changed_files" \
                  | grep -E '^helloworld-server/k8s/ingress/.*\\.ya?ml$' || true)

                mkdir -p helloworld-server
                echo "$svc_from_code" | tr '\n' ' ' > helloworld-server/changed_code.txt
                echo "$svc_from_k8s"  | tr '\n' ' ' > helloworld-server/changed_k8s.txt
                if [ -n "$ingress_changed" ]; then echo "true" > helloworld-server/ingress_changed; else : > helloworld-server/ingress_changed; fi

                echo "Code-changed services: $(cat helloworld-server/changed_code.txt)"
                echo "K8s-changed services : $(cat helloworld-server/changed_k8s.txt)"
                echo "Ingress changed      : $(cat helloworld-server/ingress_changed | tr -d '\n' | sed -e 's/^$/false/')"
              '''
            }
            env.CHANGED_CODE    = sh(script: "cat helloworld-server/changed_code.txt 2>/dev/null", returnStdout: true).trim()
            env.CHANGED_K8S     = sh(script: "cat helloworld-server/changed_k8s.txt  2>/dev/null", returnStdout: true).trim()
            env.INGRESS_CHANGED = sh(script: "cat helloworld-server/ingress_changed 2>/dev/null", returnStdout: true).trim()

            def buildSet  = (env.CHANGED_CODE ?: "").trim()
            def merged    = (env.CHANGED_CODE + " " + env.CHANGED_K8S).trim()
            def deploySet = merged ? merged.tokenize().unique().join(' ') : ''

            env.BUILD_SERVICES  = buildSet
            env.DEPLOY_SERVICES = deploySet

            echo "BUILD_SERVICES : ${env.BUILD_SERVICES ?: '<none>'}"
            echo "DEPLOY_SERVICES: ${env.DEPLOY_SERVICES ?: '<none>'}"
          }
        }
      }
    }

    stage('Docker build & push (Kaniko)') {
      when { expression { return (env.BUILD_SERVICES ?: "").trim() } }
      steps {
        gitlabCommitStatus(name: '4) build&push') {
          container('kaniko') {
            withCredentials([usernamePassword(credentialsId: env.DH_CREDS, usernameVariable: 'DH_USER', passwordVariable: 'DH_TOKEN')]) {
              sh '''
set -eux
rm -f /kaniko/.docker/config.json
mkdir -p /kaniko/.docker
auth="$(printf "%s:%s" "$DH_USER" "$DH_TOKEN" | base64 | tr -d '\n')"
cat >/kaniko/.docker/config.json <<EOF
{"auths":{"https://index.docker.io/v1/":{"auth":"$auth"}}}
EOF

SHA="${GIT_COMMIT:0:7}"
echo "[kaniko] BUILD_SERVICES=${BUILD_SERVICES}  SHA=${SHA}"

for svc in ${BUILD_SERVICES}; do
  ctx="helloworld-server/${svc}"
  df="${ctx}/Dockerfile"
  [ -f "${df}" ] || { echo "[kaniko] skip: ${df} not found (svc=${svc})"; continue; }

  img="${REGISTRY}/${IMAGE_REPO}:${svc}-${SHA}"
  latest="${REGISTRY}/${IMAGE_REPO}:${svc}-latest"

  echo "[kaniko] ==> Build/Push ${img}"
  /kaniko/executor \
    --context="${ctx}" \
    --dockerfile="${df}" \
    --destination="${img}" \
    --destination="${latest}" \
    --single-snapshot \
    --verbosity=info
done
'''
            }
          }
        }
      }
    }

    stage('Ensure namespace (optional)') {
      steps {
        gitlabCommitStatus(name: '5) ensure-ns') {
          container('kubectl') {
            sh '''
              set -e
              kubectl get ns ${K8S_NS} >/dev/null 2>&1 || echo "NOTE: namespace ${K8S_NS} not found (skip creating in this pipeline)"
            '''
          }
        }
      }
    }

    stage('Deploy to k3s (services)') {
      when { expression { return (env.DEPLOY_SERVICES ?: "").trim() } }
      steps {
        gitlabCommitStatus(name: '6) deploy-services') {
          container('kubectl') {
            sh '''
bash -euo pipefail -c '
SHA="${GIT_COMMIT:0:7}"
ns="${K8S_NS}"

for svc in ${DEPLOY_SERVICES}; do
  man_dir="helloworld-server/k8s/apps/${svc}"
  img="${REGISTRY}/${IMAGE_REPO}:${svc}-${SHA}"

  if [ -d "$man_dir" ]; then
    echo "==> apply ${man_dir}"
    kubectl -n "${ns}" apply -f "${man_dir}"
  else
    echo "warn: manifest dir not found: ${man_dir}"
    continue
  fi

  if kubectl -n "${ns}" get statefulset "${svc}" >/dev/null 2>&1; then
    kind="statefulset"
  elif kubectl -n "${ns}" get deploy "${svc}" >/devNull 2>&1; then
    kind="deploy"
  else
    echo "warn: no Deployment/StatefulSet named ${svc} (skip rolling)"
    continue
  fi

  if echo " ${CHANGED_CODE} " | grep -q " ${svc} "; then
    echo "==> Rolling (code-changed) ${svc} -> ${img}"
    if [ "${kind}" = "statefulset" ]; then
      kubectl -n "${ns}" set image statefulset/${svc} ${svc}="${img}"
      kubectl -n "${ns}" rollout status statefulset/${svc} --timeout=300s
    else
      kubectl -n "${ns}" set image deploy/${svc} ${svc}="${img}"
      kubectl -n "${ns}" rollout status deploy/${svc} --timeout=300s
    fi
  else
    echo "==> K8s-only change for ${svc}: skip image update"
  fi
done
'
'''
          }
        }
      }
    }

    stage('Deploy to k3s (ingress)') {
      when { expression { return (env.INGRESS_CHANGED ?: "").trim() } }
      steps {
        gitlabCommitStatus(name: '7) deploy-ingress') {
          container('kubectl') {
            sh '''
              set -e
              if [ -d "helloworld-server/k8s/ingress" ]; then
                echo "==> Ingress changed: applying helloworld-server/k8s/ingress"
                kubectl -n ${K8S_NS} apply -f helloworld-server/k8s/ingress
              else
                echo "skip: ingress dir not found"
              fi
            '''
          }
        }
      }
    }
  }

  post {
    success {
      updateGitlabCommitStatus name: '8) overall', state: 'success'
      script { currentBuild.description = "OK" }
    }
    failure {
      updateGitlabCommitStatus name: '8) overall', state: 'failed'
      script { currentBuild.description = "Failed" }
    }
    aborted {
      updateGitlabCommitStatus name: '8) overall', state: 'canceled'
    }
  }
}