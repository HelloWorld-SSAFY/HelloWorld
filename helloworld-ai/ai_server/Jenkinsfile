// Jenkinsfile (helloworld-ai 전용) — GitLab 커밋 상태 연동 포함
properties([
  gitLabConnection('jenkins-gitlab-api')  // Jenkins > Configure System에 등록된 GitLab 연결 ID
])

pipeline {
  agent {
    kubernetes {
      label 'k8s-ephemeral'
      defaultContainer 'jnlp'
      yaml '''
apiVersion: v1
kind: Pod
metadata:
  labels: { ci: jenkins }
spec:
  serviceAccountName: jenkins
  restartPolicy: Never
  securityContext: { fsGroup: 1000 }
  containers:
    - name: jnlp
      image: jenkins/inbound-agent:latest
      tty: true
      securityContext: { runAsUser: 1000, runAsGroup: 1000 }

    - name: kaniko
      image: gcr.io/kaniko-project/executor:debug
      command: ["sh","-c","trap : TERM INT; sleep infinity & wait"]
      volumeMounts:
        - name: docker-config
          mountPath: /kaniko/.docker
      securityContext: { runAsUser: 0 }

    - name: kubectl
      image: alpine:3.20
      imagePullPolicy: IfNotPresent
      securityContext: { runAsUser: 0 }   # apk 설치용 루트
      command: ["sh","-lc","set -eux; \
        apk add --no-cache curl ca-certificates; \
        arch=$(uname -m); case $arch in x86_64) arch=amd64 ;; aarch64) arch=arm64 ;; *) echo unsupported: $arch; exit 1 ;; esac; \
        curl -fsSL -o /usr/local/bin/kubectl https://dl.k8s.io/release/v1.33.4/bin/linux/${arch}/kubectl; \
        chmod +x /usr/local/bin/kubectl; \
        kubectl version --client=true; \
        trap : TERM INT; sleep infinity & wait"]
      tty: true
      workingDir: /home/jenkins/agent

  volumes:
    - name: docker-config
      emptyDir: {}
'''
    }
  }

  options { timestamps(); ansiColor('xterm') }

  environment {
    REGISTRY   = "docker.io"
    IMAGE_REPO = "opensongce/msa"
    K8S_NS     = "apps"
    DH_CREDS   = "dockerhub-ci"

    // 파이프라인 고정 값
    ROOT_DIR   = "helloworld-ai"
    SVC_DIR    = "ai_server"       // Dockerfile 위치
    APP_NAME   = "aiserver"        // Deployment/이미지 이름 (라벨 app=aiserver 가정)
    MAN_DIR    = "helloworld-ai/k8s/apps/aiserver" // k8s 매니페스트 디렉터리
  }

  stages {
    stage('Checkout') {
      steps {
        gitlabCommitStatus(name: '1) checkout') {
          checkout scm
          sh 'git --version; git rev-parse --short HEAD'
        }
      }
    }

    stage('Compute SHA') {
      steps {
        gitlabCommitStatus(name: '2) compute-sha') {
          script {
            env.SHA = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
            echo "Using SHA=${env.SHA}"
          }
        }
      }
    }

    stage('Detect changed (code/k8s/fixtures/migrations)') {
      steps {
        gitlabCommitStatus(name: '3) detect-changes') {
          script {
            sh '''
              set -e
              base=${GIT_PREVIOUS_SUCCESSFUL_COMMIT:-$(git rev-list --max-parents=0 HEAD)}
              changed_files=$(git diff --name-only "$base"...HEAD || true)

              code_changed=$(printf "%s\n" "$changed_files" \
                | grep -E "^${ROOT_DIR}/${SVC_DIR}/" || true)

              k8s_changed=$(printf "%s\n" "$changed_files" \
                | grep -E "^${MAN_DIR}/.*\\.ya?ml$" || true)

              fix_changed=$(printf "%s\n" "$changed_files" \
                | grep -E "^${ROOT_DIR}/${SVC_DIR}/api/fixtures/.*\\.json$" || true)

              mig_changed=$(printf "%s\n" "$changed_files" \
                | grep -E "^${ROOT_DIR}/${SVC_DIR}/api/migrations/.*\\.py$" || true)

              echo "$code_changed" > .code_changed
              echo "$k8s_changed"  > .k8s_changed
              echo "$fix_changed"  > .fix_changed
              echo "$mig_changed"  > .mig_changed
            '''
            env.CODE_CHANGED = sh(script: "test -s .code_changed && echo yes || echo no", returnStdout: true).trim()
            env.K8S_CHANGED  = sh(script: "test -s .k8s_changed  && echo yes || echo no", returnStdout: true).trim()
            env.FIX_CHANGED  = sh(script: "test -s .fix_changed  && echo yes || echo no", returnStdout: true).trim()
            env.MIG_CHANGED  = sh(script: "test -s .mig_changed  && echo yes || echo no", returnStdout: true).trim()
            echo "CODE_CHANGED=${env.CODE_CHANGED}, K8S_CHANGED=${env.K8S_CHANGED}, FIX_CHANGED=${env.FIX_CHANGED}, MIG_CHANGED=${env.MIG_CHANGED}"
          }
        }
      }
    }

    stage('Docker build & push (Kaniko)') {
      when { expression { return env.CODE_CHANGED == 'yes' } }
      steps {
        gitlabCommitStatus(name: '4) docker-build') {
          container('kaniko') {
            withCredentials([usernamePassword(credentialsId: env.DH_CREDS, usernameVariable: 'DH_USER', passwordVariable: 'DH_TOKEN')]) {
              sh '''
set -eux

# 1) Docker auth JSON
rm -f /kaniko/.docker/config.json
mkdir -p /kaniko/.docker
auth="$(printf "%s:%s" "$DH_USER" "$DH_TOKEN" | base64 | tr -d '\n')"
cat >/kaniko/.docker/config.json <<EOF
{"auths":{"https://index.docker.io/v1/":{"auth":"$auth"}}}
EOF

# 2) 빌드/푸시
ctx="${ROOT_DIR}/${SVC_DIR}"
df="${ctx}/Dockerfile"

img="${REGISTRY}/${IMAGE_REPO}:${APP_NAME}-${SHA}"
latest="${REGISTRY}/${IMAGE_REPO}:${APP_NAME}-latest"

echo "[kaniko] Build ${img}"
/kaniko/executor \
  --context="${ctx}" \
  --dockerfile="${df}" \
  --destination="${img}" \
  --destination="${latest}" \
  --single-snapshot \
  --verbosity=info
'''
            }
          }
        }
      }
    }

    stage('Apply K8s manifests') {
      when { expression { return env.K8S_CHANGED == 'yes' || env.CODE_CHANGED == 'yes' } }
      steps {
        gitlabCommitStatus(name: '6) k8s-apply') {
          container('kubectl') {
            sh '''
set -eux
ns="${K8S_NS}"
man_dir="${MAN_DIR}"
kubectl -n "${ns}" apply -f "${man_dir}"
'''
          }
        }
      }
    }

    stage('Rollout image if code changed') {
      when { expression { return env.CODE_CHANGED == 'yes' } }
      steps {
        gitlabCommitStatus(name: 'k8s-rollout') {
          container('kubectl') {
            sh '''
set -eux
ns="${K8S_NS}"
img="${REGISTRY}/${IMAGE_REPO}:${APP_NAME}-${SHA}"

kubectl -n "${ns}" set image deploy/${APP_NAME} ${APP_NAME}="${img}"
kubectl -n "${ns}" rollout status deploy/${APP_NAME} --timeout=300s
'''
          }
        }
      }
    }

    stage('Seed if fixtures/migrations changed') {
      when {
        expression { return env.FIX_CHANGED == 'yes' || env.MIG_CHANGED == 'yes' }
      }
      steps {
        gitlabCommitStatus(name: '7) db-seed') {
          container('kubectl') {
            sh '''
set -eux
ns="${K8S_NS}"
app="${APP_NAME}"

# Ready Pod 하나 잡기(최대 60초 대기)
for i in $(seq 1 30); do
  POD=$(kubectl -n "${ns}" get po -l app=${app} -o jsonpath='{.items[?(@.status.phase=="Running")].metadata.name}' | awk '{print $1}')
  if [ -n "${POD:-}" ]; then break; fi
  sleep 2
done
test -n "${POD:-}" || (echo "no running pod for app=${app}" && exit 1)

# migrate -> loaddata -> 검증
kubectl -n "${ns}" exec -i "${POD}" -- sh -lc '
  set -e
  python manage.py migrate --noinput &&
  python manage.py loaddata api/fixtures/place_inside.json api/fixtures/place_outside.json &&
  python manage.py shell -c "from api.models import PlaceInside,PlaceOutside; print(\\"seeded\\", PlaceInside.objects.count(), PlaceOutside.objects.count())"
'
'''
          }
        }
      }
    }
  }

  post {
    success {
      script {
        // 전체 파이프라인 최종 상태를 success로 업데이트 (선택)
        updateGitlabCommitStatus name: 'pipeline', state: 'success'
        currentBuild.description = "OK"
      }
    }
    failure {
      script {
        updateGitlabCommitStatus name: 'pipeline', state: 'failed'
        currentBuild.description = "Failed"
      }
    }
    unstable {
      script {
        updateGitlabCommitStatus name: 'pipeline', state: 'canceled'
        currentBuild.description = "Unstable"
      }
    }
  }
}
