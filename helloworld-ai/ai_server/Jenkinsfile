// Jenkinsfile (helloworld-ai 전용)
pipeline {
  agent {
    kubernetes {
      label 'k8s-ephemeral'
      defaultContainer 'jnlp'
      yaml """
apiVersion: v1
kind: Pod
metadata:
  labels: { ci: jenkins }
spec:
  serviceAccountName: jenkins
  restartPolicy: Never
  securityContext: { fsGroup: 1000 }
  containers:
    - name: jnlp
      image: jenkins/inbound-agent:latest
      tty: true
      securityContext: { runAsUser: 1000, runAsGroup: 1000 }

    - name: kaniko
      image: gcr.io/kaniko-project/executor:debug
      command: ["sh","-c","trap : TERM INT; sleep infinity & wait"]
      volumeMounts:
        - name: docker-config
          mountPath: /kaniko/.docker
      securityContext: { runAsUser: 0 }

    - name: kubectl
      image: alpine:3.20
      imagePullPolicy: IfNotPresent
      command: ["sh","-lc","set -eux; \
        apk add --no-cache curl ca-certificates; \
        arch=$(uname -m); case $arch in x86_64) arch=amd64 ;; aarch64) arch=arm64 ;; *) echo unsupported: $arch; exit 1 ;; esac; \
        curl -fsSL -o /usr/local/bin/kubectl https://dl.k8s.io/release/v1.33.4/bin/linux/${arch}/kubectl; \
        chmod +x /usr/local/bin/kubectl; \
        kubectl version --client=true; \
        trap : TERM INT; sleep infinity & wait"]
      tty: true
      workingDir: /home/jenkins/agent
      securityContext: { runAsUser: 1000, runAsGroup: 1000 }


  volumes:
    - name: docker-config
      emptyDir: {}
"""
    }
  }

  options { timestamps(); ansiColor('xterm') }

  environment {
    REGISTRY   = "docker.io"
    IMAGE_REPO = "opensongce/msa"
    K8S_NS     = "apps"
    DH_CREDS   = "dockerhub-ci"

    // 이 파이프라인 고정 값
    ROOT_DIR   = "helloworld-ai"
    SVC_DIR    = "ai_server"      // Dockerfile 위치
    APP_NAME   = "aiserver"       // Deployment/이미지 이름
    MAN_DIR    = "helloworld-ai/k8s/apps/aiserver" // k8s 매니페스트 디렉터리
  }

  stages {
    stage('Checkout') {
      steps {
        checkout scm
        sh 'git --version; git rev-parse --short HEAD'
      }
    }

    stage('Detect changed (code/k8s/ingress)') {
      steps {
        script {
          sh '''
            set -e
            base=${GIT_PREVIOUS_SUCCESSFUL_COMMIT:-$(git rev-list --max-parents=0 HEAD)}
            changed_files=$(git diff --name-only "$base"...HEAD || true)

            code_changed=$(printf "%s\n" "$changed_files" \
              | grep -E "^${ROOT_DIR}/${SVC_DIR}/" || true)

            k8s_changed=$(printf "%s\n" "$changed_files" \
              | grep -E "^${MAN_DIR}/.*\\.ya?ml$" || true)

            echo "$code_changed" > .code_changed
            echo "$k8s_changed"  > .k8s_changed
          '''
          env.CODE_CHANGED = sh(script: "test -s .code_changed && echo yes || echo no", returnStdout: true).trim()
          env.K8S_CHANGED  = sh(script: "test -s .k8s_changed  && echo yes || echo no", returnStdout: true).trim()
          echo "CODE_CHANGED=${env.CODE_CHANGED}, K8S_CHANGED=${env.K8S_CHANGED}"
        }
      }
    }

    stage('Docker build & push (Kaniko)') {
      when { expression { return env.CODE_CHANGED == 'yes' } }
      steps {
        container('kaniko') {
          withCredentials([usernamePassword(credentialsId: env.DH_CREDS, usernameVariable: 'DH_USER', passwordVariable: 'DH_TOKEN')]) {
            sh '''
set -eux
rm -f /kaniko/.docker/config.json
mkdir -p /kaniko/.docker
auth="$(printf "%s:%s" "$DH_USER" "$DH_TOKEN" | base64 | tr -d '\n')"
cat >/kaniko/.docker/config.json <<EOF
{"auths":{"https://index.docker.io/v1/":{"auth":"$auth"}}}
EOF

SHA="$(git rev-parse --short HEAD)"
ctx="${ROOT_DIR}/${SVC_DIR}"
df="${ctx}/Dockerfile"

img="${REGISTRY}/${IMAGE_REPO}:${APP_NAME}-${SHA}"
latest="${REGISTRY}/${IMAGE_REPO}:${APP_NAME}-latest"

echo "[kaniko] Build ${img}"
/kaniko/executor \
  --context="${ctx}" \
  --dockerfile="${df}" \
  --destination="${img}" \
  --destination="${latest}" \
  --single-snapshot \
  --verbosity=info
'''
          }
        }
      }
    }

    stage('Apply K8s manifests') {
      steps {
        container('kubectl') {
          sh '''
set -eux
ns="${K8S_NS}"
man_dir="${MAN_DIR}"
kubectl -n "${ns}" apply -f "${man_dir}"
'''
        }
      }
    }

    stage('Rollout image if code changed') {
      when { expression { return env.CODE_CHANGED == 'yes' } }
      steps {
        container('kubectl') {
          sh '''
set -eux
ns="${K8S_NS}"
SHA="$(git rev-parse --short HEAD)"
img="${REGISTRY}/${IMAGE_REPO}:${APP_NAME}-${SHA}"

# aiserver Deployment만 고려
kubectl -n "${ns}" set image deploy/${APP_NAME} ${APP_NAME}="${img}"
kubectl -n "${ns}" rollout status deploy/${APP_NAME} --timeout=300s
'''
        }
      }
    }
  }

  post {
    failure { script { currentBuild.description = "Failed" } }
    success { script { currentBuild.description = "OK" } }
  }
}
